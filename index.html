<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crypto Pattern Matcher - v2.4</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> <!-- Chart.js from CDN -->
  <script type="module" src="strategies.js" defer></script> <!-- External strategies file -->

  <style>
    body { font-family: Arial, sans-serif; background: #f4f6f9; color: #333; margin: 0; padding: 20px; }
    header { text-align: center; padding: 20px 0; font-size: 2rem; background: #2196f3; color: white; border-radius: 8px; }
    .container { display: flex; flex-direction: column; gap: 20px; justify-content: space-between; margin-top: 30px; }
    .chart-container { width: 100%; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); margin: auto; }
    .loading { font-size: 18px; color: red; }
    .debug { font-size: 14px; color: #555; margin-top: 10px; height: 400px; overflow-y: auto; background: #f1f1f1; padding: 10px; border-radius: 8px; border: 1px solid #ddd; display: block; width: 100%; }
    .strategies { margin-top: 20px; padding: 10px; background: #e0f7fa; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); width: 100%; }
    .strategy { padding: 10px; background: #ffffff; border-radius: 6px; margin-bottom: 5px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }
    .strategy.match { background: #c8e6c9; } /* Green for matched */
    .strategy.no-match { background: #ffebee; } /* Red for no match */
  </style>
</head>
<body>
  <header>Crypto Pattern Matcher - v2.4</header>

  <div class="container">
    <div class="chart-container">
      <canvas id="priceChart" width="800" height="400"></canvas> <!-- Chart container -->
    </div>
    <div class="loading" id="loadingMessage">Loading Data...</div>
    <!-- Removed old strategy box -->
    <div id="strategyResults" class="strategies"></div> <!-- New strategy results output -->
    <div id="debugInfo" class="debug"></div> <!-- Debugging output -->
  </div>

  <script>
    let version = 2.4; // Incremented version number
    document.title = `Crypto Pattern Matcher - v${version.toFixed(1)}`;
    let isDataFetched = false; // Flag to prevent redundant data fetches
    let isChartUpdated = false; // Flag to prevent redundant chart updates

    // Function to fetch data for 1 day with retry logic
    async function fetchCryptoData(symbol = 'bitcoin') {
      showDebugData('Stage: Starting data fetch for last 1 day...');
      
      const fetchWithTimeout = async (url, timeout) => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        try {
          const response = await fetch(url, { signal: controller.signal });
          clearTimeout(timeoutId);
          return response;
        } catch (error) {
          throw new Error(error.message);
        }
      };

      try {
        // Try fetching data, with a 10-second timeout
        const res = await fetchWithTimeout(`https://api.coingecko.com/api/v3/coins/${symbol}/market_chart?vs_currency=usd&days=1`, 10000);
        
        // Log the full response to inspect the data (without printing price data)
        const data = await res.json();
        showDebugData('API Response received');
        showDebugData(`Data: Prices count = ${data.prices ? data.prices.length : 0}`); // Show only count, not price data

        // Check if data.prices exists and has valid data
        if (!data.prices || !Array.isArray(data.prices)) {
          showDebugData('Stage: Error - Invalid data format');
          showDebugData('Error: data.prices is undefined or not an array');
          return [];
        }

        showDebugData('Stage: Data fetched successfully');
        return data.prices.map(([timestamp, price]) => ({ timestamp, price }));
      } catch (error) {
        showDebugData('Stage: Error fetching data');
        showDebugData(`Error: ${error.message}`);
        return [];
      }
    }

    // Function to display debug messages
    function showDebugData(message, data = null) {
      const debugInfoElement = document.getElementById('debugInfo');
      debugInfoElement.innerHTML += `${message}<br>`; // Always show message
      if (data) {
        debugInfoElement.innerHTML += `<pre>${data}</pre><br>`; // Show additional data if needed
      }
      debugInfoElement.style.display = 'block'; // Show debug box
    }

    // Function to update the chart with dynamic data
    async function updateChartWithFetchedData() {
      if (isChartUpdated) {
        showDebugData('Stage: Chart already updated');
        return; // Prevent updating the chart multiple times
      }
      
      const priceData = await fetchCryptoData('bitcoin');
      
      if (priceData.length === 0) {
        showDebugData('Stage: No data to display on the chart');
        return;
      }

      showDebugData('Stage: Updating chart with new data');
      const ctxPrice = document.getElementById('priceChart').getContext('2d');

      if (!ctxPrice) {
        showDebugData('Stage: Error getting canvas context');
        return;
      }

      showDebugData(`Canvas size: Width = ${document.getElementById('priceChart').width}, Height = ${document.getElementById('priceChart').height}`);
      
      new Chart(ctxPrice, {
        type: 'line',
        data: {
          labels: priceData.map(item => new Date(item.timestamp).toLocaleTimeString()), // Use time format for the x-axis
          datasets: [{
            label: 'Price (USD)',
            data: priceData.map(item => item.price),
            borderColor: 'rgba(75, 192, 192, 1)',
            fill: false
          }]
        },
        options: {
          responsive: true,
          scales: {
            x: {
              title: {
                display: true,
                text: 'Time'
              }
            },
            y: {
              title: {
                display: true,
                text: 'Price (USD)'
              }
            }
          }
        }
      });

      // Hide loading message once chart is loaded
      document.getElementById('loadingMessage').style.display = 'none';
      isChartUpdated = true; // Mark the chart as updated

      showDebugData('Stage: Chart updated successfully');

      // Evaluate the trading strategies against the fetched data
      evaluateStrategies(priceData);
    }

    // Function to evaluate trading strategies
    function evaluateStrategies(priceData) {
      showDebugData('Stage: Evaluating strategies...');
      
      // Check if strategies are loaded
      if (!window.strategies || !Array.isArray(window.strategies)) {
        showDebugData('Error: Strategies file not loaded properly. Checking strategies...');

        // Check if strategies are loaded correctly
        if (window.strategies) {
          showDebugData(`Strategies object is loaded. Count: ${window.strategies.length}`);
        } else {
          showDebugData('Error: Strategies object is undefined');
        }
        return;
      }

      const results = window.strategies.map(strategy => {
        const result = strategy.evaluate(priceData);
        return {
          name: strategy.name,
          description: strategy.description,
          match: result.match,
          signal: result.signal
        };
      });

      const container = document.getElementById('strategyResults');
      container.innerHTML = ''; // Clear previous results
      results.forEach(result => {
        const div = document.createElement('div');
        div.classList.add('strategy');
        div.classList.add(result.match ? 'match' : 'no-match');
        div.innerHTML = `<strong>${result.name}</strong> (${result.signal}) - ${result.description}`;
        container.appendChild(div);
      });

      showDebugData('Stage: Strategy evaluation completed');
    }

    // Function to prevent redundant evaluations (e.g., multiple fetches and chart updates)
    async function evaluate() {
      if (isDataFetched) {
        showDebugData('Stage: Data already fetched');
        return; // Prevent redundant data fetching
      }
      
      showDebugData('Stage: Start evaluating...');
      await updateChartWithFetchedData(); // For last 1 day
      isDataFetched = true; // Mark that data has been fetched
    }

    // Initial call to evaluate and load the chart
    evaluate();
  </script>
</body>
</html>

